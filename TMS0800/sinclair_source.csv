// TI calculator simulator
// Ken Shirriff, http://righto.com/ti
// Based on patent US3934233
// Code transcribed by Phil Mainwaring
//
// This file holds the source and object code to be executed.
//
//-------------------
// Note for TMS0800 implementation: putting * right after the instruction code column sets a hardware breakpoint:
// microcode will stop - put SW7 into on position and press BTN3 for single step through microcode for that instruction.
// Breakpoint mode will exit as soon as instruction pointer is no longer at breakpoint instruction.
//-------------------
//
// _____________________________________________________________________________________________________
//
//				- - -   P R O G R A M   L I S T I N G   - - -
//
//    ROM Addr		Instruction	Label	Descriptive		Narrative
// Binary     Hex	Code	 Mask		Mnemonic
//
// _____________________________________________________________________________________________________
//23456789012345678901234567890
//        1         2         3
0,,,1408,   START    ZFA    ALL ; init - clear flags
1,,,1392,            ZFB    ALL
2,,,1792,            AKA    ALL ; clear A and C
3,,,1824,            AKC    ALL
; For display, A's MANT starts in digit 5. For computation, MANT starts in digit 6
; C holds the previous value, with MANT starting in digit 6. Digit 5 counts inputted digits
4,,,1860,   MAINLOOP SLLA   MANT ; Shift mantissa for display
5,,,1808,            AKB    ALL ; clear B
6,,,1360,   WAITSCAN SYNC ; loop until no key pressed
7,,,1376,            SCAN
8,,,518,            BINE   WAITSCAN
9,,,1319,   WAITKEY  WAITNO WAITED ; wait for key
10,,,1360,  WAITED2  SYNC ; debounce: still pressed?
11,,,1376,           SCAN
12,,,9,           BIE    WAITKEY ; loop if no key
13,,,1360,           SYNC
14,,,1908,           SRLA   MANT ; MANT is shifted right during calculation
15,,,1072,           BKO    LOWERKEY ; sequentially scan key columns
16,,,1083,           BKO    PLUSKEY
17,,,1075,           BKO    MINUSKEY
18,,,1121,           BKO    DIVKEY
19,,,1129,           BKO    MULTKEY
20,,,1073,           BKO    UPPERKEY
21,,,1069,           BKO    EKEY
22,,,1051,           BKO    ZEROKEY
23,,,1840,           EXAB   ALL ; save A in B, A=0
24,,,1955,           AKCN   DIGIT1 ; get digit by incrementing until column found
25,,,1840,           EXAB   ALL ; restore A, B holds count
26,,,516,           BINE   MAINLOOP ; start over if nothing pressed
27,,,1425,  ZEROKEY  TFB    EMODE ; B holds key 0-9
28,,,552,           BINE   EDIGIT
; If OPDONE, a digit starts a new number in A, leaving the previous in C
29,,,1430,           TFB    OPDONE ; if OPDONE...
30,,,33,           BIE    LABEL33
31,,,1792,           AKA    ALL ; then clear A and OPDONE
32,,,1398,           ZFB    OPDONE
33,,,1631,  LABEL33  ACKA   DIGIT ; C holds digit position
34,,,1920,  BSHIFT   SRLB   ALL ; shift B right C times.
35,,,1683,           SAKA   DIGIT1 ; decrement A
36,,,34,           BIE    BSHIFT ; (no borrow)
37,,,2003,           ACKC   DIGIT1 ; increment digit count in C
38,,,1540,           AABA   MANT ; Append new digit
39,,,4,           BIE    MAINLOOP ; done digit processing
40,,,1399,  EDIGIT   ZFB    NEWEXP ; clear new exponent flag
41,,,1858,           SLLA   EXP ; shift exponent left
42,,,1872,           SLLB   ALL ; shift digit left
43,,,1538,           AABA   EXP ; append new digit to exponent
44,,,4,           BIE    MAINLOOP ; done
45,,,1329,  EKEY     SFB    EMODE ; entering exponent mode
46,,,1335,           SFB    NEWEXP
47,,,4,           BIE    MAINLOOP ; done
48,,,1349,  LOWERKEY SFA    LOW ; LOW and UP_LOW set for LOWER key
49,,,1347,  UPPERKEY SFA    UP_LOW ; UP_LOW set for UPPER key
50,,,4,           BIE    MAINLOOP ; done
51,,,1443,  MINUSKEY TFA    UP_LOW ; alt-MINUS is COS
52,,,676,           BINE   COSKEY
; Minus normally is just addition after negating A.
; Except - following E changes the exponent sign instead.
; Except a second minus following E - does a subtraction
53,,,1431,           TFB    NEWEXP ; - follows E?
54,,,57,           BIE    DOSUBTR
55,,,1559,           AAKA   EXP_S5 ; negate exponent for E - keystrokes
56,,,4,           BIE    MAINLOOP ; if already neg, fall through subtract
57,,,1553,  DOSUBTR  AAKA   MANT_S5 ; negate mantissa then fall through and add
58,,,59,           BIE    PLUSKEY ; clear condition flag
59,,,1443,  PLUSKEY  TFA    UP_LOW ; alt-PLUS is SIN
60,,,677,           BINE   SINKEY
; Add A and C. First, C is copied to B. The numbers need to have equal
; exponents to be added so the difference in exponents is 
; computed using C and B is shifted left to align the mantissas.
; If the mantissas have different signs, they are subtracted instead of added,
; which may require A and B to be swapped.
61,,,1839,  ADDSUB   AKC    DIGIT ; Clear C DIGIT
62,,,1632,           ACKB   ALL ; copy C to B
63,,,2018,           ABAC   EXP ; add exponents into C
64,,,65,           BIE    CLRCC ; Clear condition code
65,,,2023,  CLRCC    ABAC   EXP_S5 ; add exponent signs
66,,,1719,           SCKC   EXP_S5 ; subtract 5 from sign
67,,,72,           BIE    EXPSNES ; signs were different
68,,,1730,           CAB    EXP ; compare exponents
69,,,71,           BIE    EXPAGE ; branch >=
70,,,1840,           EXAB   ALL ; switch arguments so A EXP > B EXP
71,,,1666,  EXPAGE   SABC   EXP ; same sign - subtract exponents into C
72,,,1751,  EXPSNES  CAK    EXP_S5 ; Test A exponent sign
73,,,587,           BINE   AEXPPOS ; branch on borrow, A exp sign == 0
74,,,1840,           EXAB   ALL ; switch arguments so A EXP > B EXP
75,,,1754,  AEXPPOS  CAK    MANT1 ; make sure A is nonzero
76,,,78,           BIE    BSHIFT2
77,,,1840,           EXAB   ALL
78,,,1718,  BSHIFT2  SCKC   EXP1 ; shift B by difference in exponents (C) to line up
79,,,594,           BINE   DONE2
80,,,1924,           SRLB   MANT
81,,,78,           BIE    BSHIFT2 ; branch every time
82,,,2017,  DONE2    ABAC   MANT_S5 ; add mantissa signs and subtract 5
83,,,1713,           SCKC   MANT_S5
84,,,89,           BIE    SUBMANT ; signs different
85,,,1540,  TRYADD   AABA   MANT ; add mantissas, or restore A if did SUBMANT
86,,,130,           BIE    NORMLIZE ; branch if no overflow, i.e. did add
87,,,1844,           EXAB   MANT ; failed subtract: swap A and B and try again.
88,,,1841,           EXAB   MANT_S5
; Try subtracting mantissas: A-B. If B>A, add B back, swap, and try again
89,,,1652,  SUBMANT  SABA   MANT ; subtract mantissa
90,,,597,          BINE   TRYADD ; A was smaller than B: try again
91,,,130,           BIE    NORMLIZE ; branch every time, done
; Multiplication: add exponents with different signs
92,,,1730,  SIGNSNE  CAB    EXP ; compare EXP magnitudes
93,,,95,           BIE    SUBEXPS ; branch if |A| >= |B|
94,,,1849,           EXAB   EXPSGNS1 ; swap exponents and signs
; At this point, |A| >= |B|, so can subtract and A's sign won't change
95,,,1650,  SUBEXPS  SABA   EXP ; subtract EXPs

96,,,,           BIE    EXPSDONE ; branch every time
; Division entry point: compute C / A.
; First, normalize A mantissa since repeatedly subtracting A depends on
; having A normalized. Next, use multiply's add-exponent code to subtract
; A's exponent from C's.
; The DIVLOOP loop repeatedly subtracts B from C, counting into A.
; Successive loops shift by 10 to perform long division.
97,,,,  DIVKEY   TFA    UP_LOW ; entry point for DIV
98,,,,           BINE   TANKEY ; alt-DIV is TAN
99,,,,           SFA    COS_TAN ; reusing flag to indicate division
100,,,, DODIV    SFA    RET1FLAG ; 'subroutine call' flag
101,,,,          BIE    NORMLIZE ; 'Subroutine call' to normalize A
102,,,, RET1     ZFA    RET1FLAG ; 'Return' here after NORMLIZE
103,,,,          AAKA   EXP_S5 ; toggle A's EXP sign since dividing not multiplying
104,,,,          BIE    MULTKEY ; clear cc
; Multiply by adding exponents and multiplying mantissas
; If COS_TAN set, divide by adding exponents, then jump to DIVMANT
; i.e. the code to add exponents is reused for division
105,,,, MULTKEY  TFA    UP_LOW ; alt-MULT is LOG
106,,,,          BINE   LOGKEY
107,,,,          AKC    DIGIT ; clear entered digit count
108,,,,          ACKB   ALL ; copy C to B
109,,,,          EXAB   MANT
; Add exponents; tricky if signs are different
110,,,,          ABAC   EXP_S5
111,,,,          SCKC   EXP_S5
112,,,,          BIE    SIGNSNE ; if signs different, use SIGNSNE
113,,,,          AABA   EXP ; simply add exponents
114,,,, EXPSDONE AABA   MANT_S5 ; xor signs
115,,,,          BIE    CLRCC2 ; clear before test
116,,,, CLRCC2   TFA    COS_TAN ; set if dividing
; Compute A = B * C mantissas; EXP already computed
117,,,, MULTMANT AKA    MANT ; clear mantissa
118,,,,          BINE   DIVMANT ; branch if dividing
119,,,, MLTLOOP1 SRLA   MANT ; multiply B * C
120,,,, MLTLOOP2 CCK    MANTLOW1 ; Add B to A, repeat low digit of C times
121,,,,          BINE   MULTSHFT
122,,,,          SCKC   MANT1
123,,,,          AABA   MANT
124,,,,          BIE    MLTLOOP2
125,,,, MULTSHFT SRLC   MANT ; shift C right
126,,,,          CCK    MANT1
127,,,,          BIE    MLTLOOP1 ; loop if not done
128,,,,          TFA    LOW
129,,,,          BINE   ALOGRET ; Return to ALOGRET if LOW flag set (ANTILOG)
; Normalizes mantissa by removing leading zeros.
; This is called to finish up after an operation
; Also subroutine call; RET1FLAG will cause return to RET1
130,,,, NORMLIZE CAK    MANT1 ; Test if mantissa is < 1
131,,,,          BINE   START ; if mantissa is 0, reset
; Repeatedly shift MANT left until a value in the 5 digit.
; Decrement EXP each step to compensate
132,,,, MANTSHL  CAK    DIGIT1 ; Loop to left-align mantissa
133,,,,          BIE    MANTOK ; Branch if mantissa aligned
134,,,,          SLLA   MANT ; Shift mantissa left
; Decrementing the exponent is a bit tricky because sign is separate
; Cases are: positive exponent, exponent becoming -1, and negative exponent
135,,,,          CAK    EXP_S5 ; Check exponent sign
136,,,,          BIE    EXPNEG ; Branch if negative
137,,,,          SAKA   EXP1 ; Decrement exponent
138,,,,          BIE    EXPPOS3 ; Branch if no borrow
139,,,,          AKA    EXP_S5 ; EXP went negative: Set exponent sign
140,,,,          AKA    EXP1 ; Set exponent to 1
141,,,, EXPPOS3  SAKA   EXP1 ; Decrement exponent to cancel next instruction 
142,,,, EXPNEG   AAKA   EXP1 ; For negative exponent, inc EXP to decrement
143,,,,          BIE    MANTSHL ; two branches to clear condition flag
144,,,,          BIE    MANTSHL
; At this point, mantissa is left-aligned into digit 5
; Now shift one position right and increment exponent, taking sign into account
145,,,, MANTOK   SRLA   MANT
146,,,,          CAK    EXP_S5 ; Test exponent sign
147,,,,          BINE   EXPPOS
148,,,,          SAKA   EXP1 ; Decrement exponent
149,,,,          SAKA   EXP1 ; Decrement exponent
150,,,, EXPPOS   AAKA   EXP1 ; Increment exponent
151,,,,          BIE    CLRCC1 ; clear condition
152,,,, CLRCC1   TFA    RET1FLAG ; Subroutine return
153,,,,          BINE   RET1 ; return to RET1 if RET1FLAG set
; returned if RET1FLAG set, otherwise clean up...
; clear B, set OPDONE, clear A flags, fix EXP sign, copy A result to C
154,,,,          ZFB    ALL ; Clear B
155,,,,          SFB    OPDONE ; Set op done flag?
156,,,,          ZFA    ALL ; Clear A flags
; Fix EXP of -00 if necessary
157,,,,          CAK    EXP1 ; Is exponent zero (< 1)
158,,,,          BIE    EXPPOS2
159,,,, CLEARSGN AAKA   EXP_S5 ; Flip sign
160,,,,          BIE    CLEARSGN ; Branch if sign was clear before
161,,,, EXPPOS2  AAKC   ALL ; Copy A to C
162,,,,          BIE    MAINLOOP ; BET
; Entry points for TAN, COS, and SIN
163,,,, TANKEY   SFA    TAN
164,,,, COSKEY   SFA    COS_TAN
165,,,, SINKEY   SAKA   EXP1 ; shift mantissa by exponent
166,,,,          BINE   DONESHFT
167,,,,          SRLA   MANT
168,,,,          BIE    SINKEY
169,,,, DONESHFT AKA    EXPSGNS1 ; clear signs
170,,,,          SAKA   EXPSGNS1 ; EXP = 0
171,,,,          AKC    ALL ; clear C
172,,,,          TFA    LOW ; check for ARC-
173,,,,          BIE    NORMOP ; branch if no
174,,,,          TFA    TAN ; check ARCTAN?
175,,,,          BIE    ASINCOS ; branch if no
176,,,,          AAKC   ALL ; ARCTAN: copy A to C
177,,,,          AKB    MASKA1 ; set digit in B
178,,,,          BIE    TRGLOOP2 ; branch every time
179,,,, ASINCOS  AAKA   MANTD1
180,,,, NORMOP   AKB    MANTD5 ; B = .0005 (current SIN)
181,,,,          SRLB   MANT
182,,,,          ACKC   MASKA1 ; C += 1 (current COS)
; Loop test for SIN/COS/TAN
183,,,, TRIGLOOP SAKA   MANTD1 ; rotate A times, by .001 rad
184,,,,          BINE   TRIGDONE ; branch on borrow - done
; The main trig loop. B holds sin, C holds cos.
; The loop is performed A times, rotating by .001 rad each time.
185,,,, TRGLOOP2 SLLC   ALL ; shift C to prepare for add
186,,,,          SLLC   ALL
187,,,,          SLLC   ALL
188,,,,          ACKC   MANTD5 ; C=C-B/1000 (rounded)
189,,,,          SCBC   ALL
190,,,,          SRLC   ALL ; restore C
191,,,,          SRLC   ALL
192,,,,          SRLC   ALL
193,,,,          SLLB   ALL ; shift B to prepare for add
194,,,,          SLLB   ALL
195,,,,          SLLB   ALL
196,,,,          ACKC   MANTD5 ; B=B+C/1000 (rounded)
197,,,,          ABCB   ALL
198,,,,          SCKC   MANTD5 ; restore C
199,,,,          SRLB   ALL
200,,,,          SRLB   ALL
201,,,,          SRLB   ALL
202,,,,          TFA    LOW ; ARC-op?
203,,,,          BIE    TRIGLOOP ; no: branch
; Increment ARC-trig count, check termination
204,,,,          AAKA   EXPSGNS1 ; Count iterations in top digits of A
205,,,,          TFA    TAN
206,,,,          BIE    ASINCOS1 ; branch if SIN/COS
; Test ARCTAN termination
207,,,,          CCK    DIGIT1 ; ARCTAN, compare C to K
208,,,,          BINE   TRGLOOP2 ; loop if not done
209,,,,          BIE    ARCDONE ; BET
210,,,, ASINCOS1 TFA    COS_TAN ; SIN/COS
211,,,,          BINE   ACOSCHK ; branch if COS
; Test ARCSIN termination
212,,,,          CAB    MANT ; must be SIN
213,,,,          BIE    TRGLOOP2
214,,,,          BIE    ARCDONE ; Branch every time
; Test ARCCOS termination
215,,,, ACOSCHK  CAK    MANT1 ; COS
216,,,,          EXAB   MANT ; compare C-A the hard way
217,,,,          CCB    MANT
218,,,,          EXAB   MANT
219,,,,          BIE    TRGLOOP2 ; C==A
220,,,, ARCDONE  SRLA   ALL ; shift iteration count into mantissa, divide by 1000
221,,,,          SRLA   ALL
222,,,,          SRLA   ALL
223,,,,          SRLA   ALL
224,,,,          SRLA   ALL
225,,,,          BIE    NORMLIZE ; branch every time
; SIN/COS/TAN loop done
226,,,, TRIGDONE TFA    TAN
227,,,,          BIE    SINCOS
228,,,,          ACKA   ALL ; doing TAN: A=C (denom)
229,,,,          ABOC   ALL ; C=B (numer)
230,,,,          AKB    ALL ; B=0
231,,,,          ZFA    UP_LOW
232,,,,          BIE    DODIV ; branch every time
233,,,, SINCOS   TFA    COS_TAN
234,,,,          BIE    SIN ; branch for SIN
235,,,,          ACKB   ALL ; COS: return C via B
236,,,, SIN      EXAB   ALL ; SIN: return B
237,,,,          BIE    NORMLIZE ; BET (no overflow)
238,,,, LOGKEY   TFA    LOW ; low-MULT is antilog
239,,,,          BIE    LOG
; Antilog entry point.
; The concept is to split the integer and fractional part of A. The integer
; part becomes the EXP of the result. The antilog of the fractional part is 
; computed using the equation 10^f = 10*.99^(229.15*(1-f))
; 
; First, split int and frac parts of A. Next LOGLOOP computes constant 229.15.
; Control continues at ANTILOG which calls MULTMANT to multiply 1-frac by 229.15
240,,,, DOALOG   CAK    EXP1 ; Test exponent
; Split int and frac parts of A: int in digits 1-4, frac in 7-10
; Shortcut: If EXP > 0, assume EXP is 1. Anything bigger would probably overflow
; This is totally wrong for cases like antilog(0.001E3)
241,,,,          BINE   EXPZERO ; branch if exponent is 0
242,,,,          CAK    EXP_S5; Test exponent sign
243,,,,          BINE   EXPPOS4
244,,,,          SRLA   MANT; Negative exponent: shift mantissa right to align
245,,,,          SAKA   EXP1
246,,,,          BIE    DOALOG ; Loop every time
247,,,, EXPPOS4  SLLA   MANT ; Positive EXP, assume it is 1
248,,,, EXPZERO  AKA    EXP ; Clear exponent
249,,,,          SLLA   TOPSTUFF ; Shift integer part into digits 1-4 for later
250,,,,          SLLA   TOPSTUFF
; Compute log of A.
; First compute -1/log(.99) = 229.15. Then compute -log(MANT A)/log(.99).
; Divide the results to get log(MANT A). Finally, add EXP A to get the result.
; Then compute -log(A)/go through power loop a second time
251,,,, LOG      AKC    ALL ; This entry point computes -1/log(.99) = 229.15
252,,,,          ACKC   DIGIT1 ; C = 10.00000
; LOGLOOP is used twice; once to compute the constant 229.15 and then again
; on the actual argument.
; Compute -log(C MANT) / log(.99).
; Do this by repeatedly incrementing count until (C MANT)*.99^count is < 1
; That yields count = -log(C) / log(.99) approximately
; count is stored in C EXP, and the current C*.99 in C MANT
253,,,, LOGLOOP  ACKB   MANT ; Compute log B*.99^C until < .1
254,,,,          SRLB   MANT
255,,,,          SRLB   MANT
256,,,,          SCBC   MANT ; C -= C / 100
257,,,,          TFB    NEWEXP ; indicates ALOG here
258,,,,          BINE   ALOGLOOP
259,,,,          ACKC   EXPSGNS1 ; Count number of iterations
260,,,,          CCK    MASKA1 ; C vs 100000
261,,,,          BIE    LOGLOOP ; Loop if >=
; Get a couple decimal points of accuracy by adding the remainder*100
; Explanation using Taylor series:
; .99^(epsilon*100) = 1-epsilon = 1/(1+epsilon) approximately
; So if C*.99^N = 1+epsilon, then C*.99^(N+epsilon*100) = (1+epsilon)/(1+epsilon) = 1
; Thus N + epsilon * 100 is the better approximation
262,,,,          SCBB   EXPSGNS1 ; undo last iteration: count in B EXP
263,,,,          ABCC   MANT ; undo last MANT subtract
264,,,,          SCKC   MASKA1
265,,,,          SRLB   ALL ; Shift count into B mantissa
266,,,,          SRLB   ALL
267,,,,          SRLB   ALL
268,,,,          SRLB   ALL
269,,,,          ABCB   MANT ; add epsilon*100
270,,,,          EXAB   MANT ; result in A MANT
271,,,,          TFA    LOW
272,,,,          BINE   ANTILOG ; return to ANTILOG if LOW set
273,,,,          ABOC   ALL ; Copy B (arg) to C
274,,,,          FFA    TAN ; go through loop twice, tracked by TAN flag
275,,,,          TFA    TAN
276,,,,          BINE   LOGLOOP ; back to the loop with the argument
; Second power loop done for LOG. A EXP is original EXP.
; A MANT = -log(original A MANT) / log(.99)
; B MANT = 229.15 = -1 / log(.99)
; Copy A MANT to C MANT, then compute C MANT / B MANT
; This yields A MANT = log(original A MANT)
277,,,,          AAKC   MANT
; For LOG fall-through: 229.15 in B, -log(arg)/log(.99) in A and C
; At ALOGDIV entry: 1+epsilon in B, .99^N in C
278,,,, ALOGDIV  AKA    MANT ; clear A mant, arg exp still in A
; Compute A MANT = C MANT / B MANT by long division
279,,,, DIVMANT  AKA    DIGIT4 ; start digit count at 4, iterate until 10
; The DIVLOOP loop repeatedly subtracts B from C, counting into A
280,,,, DIVLOOP  CCB    MANT ; Compare C and B to see if subtraction done
281,,,,          BINE   SHIFTDIV ; branch if C < B
282,,,,          SCBC   MANT ; C -= B
283,,,,          AAKA   MANT1 ; increment low digit of A
284,,,,          BIE    DIVLOOP ; BET
285,,,, SHIFTDIV AAKC   DIGIT1 ; increment digit count into C
286,,,,          BINE   DIVDONE ; overflow; done when count hits 10
287,,,,          SLLA   MANT ; shift A mantissa left
288,,,,          ACKA   DIGIT ; copy digit count back to A; clears flag
289,,,,          SLLC   MANT ; and shift C mantissa left
290,,,,          BIE    DIVLOOP ; branch every time
291,,,, DIVDONE  AKA    DIGIT; NOP to clear flag
292,,,,          TFA    UP_LOW ; pick the return target
293,,,,          BINE   ADDLOG ; continue for LOG
294,,,,          BIE    NORMLIZE ; done for DIV
295,,,, WAITED   BIE    WAITED2 ; inconvenient WAITNO target
; For LOG, add (original) A exponent to result via ADDSUB
296,,,, ADDLOG   AAKC   MANT ; A mantissa -> C
297,,,,          AKA    MANT ; clear A mantissa
298,,,,          SRLA   ALL ; shift exponent into top of mantissa (log of exponent)
299,,,,          SRLA   ALL
300,,,,          AKA    EXP ; clear exponent
; At this point, original EXP is in A digits 5 and 6, log of original MANT is in C
; Add them together to get final log
301,,,,          BIE    ADDSUB ; BET (clear from AAKC)
; A holds the original int part in digits 1-4, 229.15 in digits 6-10
; B holds the original fractional part in digits 6-10
302,,,, ANTILOG  AAKC   MANT ; copy 229.15 to C
303,,,,          AKA    MANT ; clear A MANT
304,,,,          AKA    MASKA1
305,,,,          SABA   MANT
306,,,,          EXAB   MANT; B holds 1 - original fractional part
307,,,,          BIE    MULTMANT ; Sub call to multiply by 229.15
308,,,, ALOGRET  SRLA   MANT
309,,,,          SFB    NEWEXP; indicates ALOG
310,,,,          BIE    LOG ; Branch every time
; conditional for LOGLOOP when doing ANTILOG
; loop number of times in A MANT
311,,,, ALOGLOOP SAKA   MANTD1 ; decrement A and if non-negative...
312,,,,          BIE    LOGLOOP ; go back to LOGLOOP
; Get a couple more digits of accuracy. The idea is that
; .99^epsilon = 1-epsilon/100 = 1/(1+epsilon/100)) approximately
; so divide by 1+remainder/100 to account for the fractional part of
; the exponent in .99^N, since the loop only does the integer part.
313,,,,          AAKA   MANTD1 ; restore A digits to 0
314,,,,          SLLA   MANT ; use the ignored digits for extra accuracy?
315,,,,          AAKA   MASKA1; A = 1 + remainder/100
316,,,,          ABCC   MANT; restore value of C from extra iteration
317,,,,          EXAB   MANT; B has correction factor, C has 10*.99^N
318,,,,          ZFA    UP_LOW
319,,,,          BINE   ALOGDIV ; BET divide and finish up ALOG
;,
; A Flags:
; 0 ALL - all flags, for clearing
; 1 (S10) RET1FLAG - indicates return to DIV
; 3 (S6) UP_LOW - indicates either UP or LOW functions
; 5 (S0) LOW - indicates a LOW function
; 7 (S9) TAN - indicates TAN selected
; 11 (S5) COS_TAN - indicates COS or TAN selected
; 
; B Flags:
; 0 ALL - all flags, for clearing
; 1 (S10) EMODE - indicates E has been pressed
; 6 (S8S7) OPDONE - indicates operation completed, waiting for number
; 7 (S9) NEWEXP: E pressed, entering a new exponent; also for ALOG
;,
; Masks:
;  S value
; a9876543210
; 00000000000 mask 0 ALL - all digits
; 5           mask 1 MANT_S5 - mantissa sign; 5 is negative
;   00        mask 2 EXP - exponent for value
;     1       mask 3 DIGIT1
;     0000000 mask 4 MANT - mantissa
;           1 mask 5 MANTLOW1 - low digit of mantissa
;   01        mask 6 EXP1 - mantissa constant 1
;  5          mask 7 EXP_S5 - exponent sign; 5 is negative
; 000000      mask 8 TOPSTUFF
; 0001        mask 9 EXPSGNS1 - exponent and signs, also a counter
;     0000001 mask a MANT1 - mantissa constant 1
;      1      mask b MASKA1 - counter or digit in mantissa
;     00005   mask c MANTD5
;     00001   mask d MANTD1
;     4       mask e DIGIT4
;     0       mask f DIGIT
];
var objectCode = [

114,1443,675,1355,1345,130,1409,1559,
105,1443,750,1839,1632,1844,2023,1719,
92,1538,1537,116,1451,1796,791,1908,
1781,637,1722,1540,120,1940,1786,119,
1445,820,1754,512,1747,145,1860,1751,
142,1686,141,1799,1798,1686,1558,132,
132,1908,1751,662,1686,1686,1558,152,
1441,614,1392,1334,1408,1750,161,1559,
159,1568,4,1351,1355,1686,681,1908,
165,1801,1689,1824,1445,180,1447,179,
1568,1819,185,1565,1820,1924,2011,1693,
738,1888,1888,1888,2012,1696,1936,1936,
1936,1872,1872,1872,2012,1584,1724,1920,
1920,1920,1445,183,1561,1447,210,1779,
697,220,1451,727,1732,185,220,1754,
1844,1764,1844,185,1904,1904,1904,1904,
1904,130,1447,233,1616,1600,1808,1411,
100,1451,236,1632,1840,130,1445,251,
1750,760,1751,759,1908,1686,240,1860,
1794,1864,1864,1824,2003,1636,1924,1924,
1700,1431,823,2009,1787,253,1993,2036,
1723,1920,1920,1920,1920,1588,1844,1445,
814,1600,1479,1447,765,1572,1796,1806,
1764,797,1700,1562,280,1571,803,1860,
1631,1892,280,1807,1443,808,130,10,
1572,1796,1904,1904,1794,61,1572,1796,
1803,1652,1844,117,1908,1335,251,1693,
253,1565,1860,1563,2036,1844,1411,790,
];

