//-----------------------------------------------------------------------------------
// Generated by AsmGenerator.exe from 'http://files.righto.com/calculator/sourceCode_sinclair.js' on 8/26/2019 12:08 AM for use in https://github.com/zpekic/Sys0800
//-----------------------------------------------------------------------------------
//Add * after the last binary digit of instruction to generate breakpoint for TMS0800
//-----------------------------------------------------------------------------------

// TI calculator simulator
// Ken Shirriff, http://righto.com/ti
// Based on patent US3934233
// Code transcribed by Phil Mainwaring
//
// This file holds the source and object code to be executed.

0 0000 0000 0000	10 11000 0000   START    ZFA    ALL ; init - clear flags
0 0000 0001 0001	10 10111 0000            ZFB    ALL
0 0000 0010 0002	11 10000 0000            AKA    ALL ; clear A and C
0 0000 0011 0003	11 10010 0000            AKC    ALL
; For display, A's MANT starts in digit 5. For computation, MANT starts in digit 6
; C holds the previous value, with MANT starting in digit 6. Digit 5 counts inputted digits
0 0000 0100 0004	11 10100 0100   MAINLOOP SLLA   MANT ; Shift mantissa for display
0 0000 0101 0005	11 10001 0000            AKB    ALL ; clear B
0 0000 0110 0006	10 10101 0000   WAITSCAN SYNC ; loop until no key pressed
0 0000 0111 0007	10 10110 0000            SCAN
0 0000 1000 0008	01 00000 0110            BINE   WAITSCAN
0 0000 1001 0009	10 10010 0111   WAITKEY  WAITNO WAITED ; wait for key
0 0000 1010 000A	10 10101 0000  WAITED2  SYNC ; debounce: still pressed?
0 0000 1011 000B	10 10110 0000           SCAN
0 0000 1100 000C	00 00000 1001           BIE    WAITKEY ; loop if no key
0 0000 1101 000D	10 10101 0000           SYNC
0 0000 1110 000E	11 10111 0100           SRLA   MANT ; MANT is shifted right during calculation
0 0000 1111 000F	10 00011 0000           BKO    LOWERKEY ; sequentially scan key columns
0 0001 0000 0010	10 00011 1011           BKO    PLUSKEY
0 0001 0001 0011	10 00011 0011           BKO    MINUSKEY
0 0001 0010 0012	10 00110 0001           BKO    DIVKEY
0 0001 0011 0013	10 00110 1001           BKO    MULTKEY
0 0001 0100 0014	10 00011 0001           BKO    UPPERKEY
0 0001 0101 0015	10 00010 1101           BKO    EKEY
0 0001 0110 0016	10 00001 1011           BKO    ZEROKEY
0 0001 0111 0017	11 10011 0000           EXAB   ALL ; save A in B, A=0
0 0001 1000 0018	11 11010 0011           AKCN   DIGIT1 ; get digit by incrementing until column found
0 0001 1001 0019	11 10011 0000           EXAB   ALL ; restore A, B holds count
0 0001 1010 001A	01 00000 0100           BINE   MAINLOOP ; start over if nothing pressed
0 0001 1011 001B	10 11001 0001  ZEROKEY  TFB    EMODE ; B holds key 0-9
0 0001 1100 001C	01 00010 1000           BINE   EDIGIT
; If OPDONE, a digit starts a new number in A, leaving the previous in C
0 0001 1101 001D	10 11001 0110           TFB    OPDONE ; if OPDONE...
0 0001 1110 001E	00 00010 0001           BIE    LABEL33
0 0001 1111 001F	11 10000 0000           AKA    ALL ; then clear A and OPDONE
0 0010 0000 0020	10 10111 0110           ZFB    OPDONE
0 0010 0001 0021	11 00101 1111  LABEL33  ACKA   DIGIT ; C holds digit position
0 0010 0010 0022	11 11000 0000  BSHIFT   SRLB   ALL ; shift B right C times.
0 0010 0011 0023	11 01001 0011           SAKA   DIGIT1 ; decrement A
0 0010 0100 0024	00 00010 0010           BIE    BSHIFT ; (no borrow)
0 0010 0101 0025	11 11101 0011           ACKC   DIGIT1 ; increment digit count in C
0 0010 0110 0026	11 00000 0100           AABA   MANT ; Append new digit
0 0010 0111 0027	00 00000 0100           BIE    MAINLOOP ; done digit processing
0 0010 1000 0028	10 10111 0111  EDIGIT   ZFB    NEWEXP ; clear new exponent flag
0 0010 1001 0029	11 10100 0010           SLLA   EXP ; shift exponent left
0 0010 1010 002A	11 10101 0000           SLLB   ALL ; shift digit left
0 0010 1011 002B	11 00000 0010           AABA   EXP ; append new digit to exponent
0 0010 1100 002C	00 00000 0100           BIE    MAINLOOP ; done
0 0010 1101 002D	10 10011 0001  EKEY     SFB    EMODE ; entering exponent mode
0 0010 1110 002E	10 10011 0111           SFB    NEWEXP
0 0010 1111 002F	00 00000 0100           BIE    MAINLOOP ; done
0 0011 0000 0030	10 10100 0101  LOWERKEY SFA    LOW ; LOW and UP_LOW set for LOWER key
0 0011 0001 0031	10 10100 0011  UPPERKEY SFA    UP_LOW ; UP_LOW set for UPPER key
0 0011 0010 0032	00 00000 0100           BIE    MAINLOOP ; done
0 0011 0011 0033	10 11010 0011  MINUSKEY TFA    UP_LOW ; alt-MINUS is COS
0 0011 0100 0034	01 01010 0100           BINE   COSKEY
; Minus normally is just addition after negating A.
; Except - following E changes the exponent sign instead.
; Except a second minus following E - does a subtraction
0 0011 0101 0035	10 11001 0111           TFB    NEWEXP ; - follows E?
0 0011 0110 0036	00 00011 1001           BIE    DOSUBTR
0 0011 0111 0037	11 00001 0111           AAKA   EXP_S5 ; negate exponent for E - keystrokes
0 0011 1000 0038	00 00000 0100           BIE    MAINLOOP ; if already neg, fall through subtract
0 0011 1001 0039	11 00001 0001  DOSUBTR  AAKA   MANT_S5 ; negate mantissa then fall through and add
0 0011 1010 003A	00 00011 1011           BIE    PLUSKEY ; clear condition flag
0 0011 1011 003B	10 11010 0011  PLUSKEY  TFA    UP_LOW ; alt-PLUS is SIN
0 0011 1100 003C	01 01010 0101           BINE   SINKEY
; Add A and C. First, C is copied to B. The numbers need to have equal
; exponents to be added so the difference in exponents is 
; computed using C and B is shifted left to align the mantissas.
; If the mantissas have different signs, they are subtracted instead of added,
; which may require A and B to be swapped.
0 0011 1101 003D	11 10010 1111  ADDSUB   AKC    DIGIT ; Clear C DIGIT
0 0011 1110 003E	11 00110 0000           ACKB   ALL ; copy C to B
0 0011 1111 003F	11 11110 0010           ABAC   EXP ; add exponents into C
0 0100 0000 0040	00 00100 0001           BIE    CLRCC ; Clear condition code
0 0100 0001 0041	11 11110 0111  CLRCC    ABAC   EXP_S5 ; add exponent signs
0 0100 0010 0042	11 01011 0111           SCKC   EXP_S5 ; subtract 5 from sign
0 0100 0011 0043	00 00100 1000           BIE    EXPSNES ; signs were different
0 0100 0100 0044	11 01100 0010           CAB    EXP ; compare exponents
0 0100 0101 0045	00 00100 0111           BIE    EXPAGE ; branch >=
0 0100 0110 0046	11 10011 0000           EXAB   ALL ; switch arguments so A EXP > B EXP
0 0100 0111 0047	11 01000 0010  EXPAGE   SABC   EXP ; same sign - subtract exponents into C
0 0100 1000 0048	11 01101 0111  EXPSNES  CAK    EXP_S5 ; Test A exponent sign
0 0100 1001 0049	01 00100 1011           BINE   AEXPPOS ; branch on borrow, A exp sign == 0
0 0100 1010 004A	11 10011 0000           EXAB   ALL ; switch arguments so A EXP > B EXP
0 0100 1011 004B	11 01101 1010  AEXPPOS  CAK    MANT1 ; make sure A is nonzero
0 0100 1100 004C	00 00100 1110           BIE    BSHIFT2
0 0100 1101 004D	11 10011 0000           EXAB   ALL
0 0100 1110 004E	11 01011 0110  BSHIFT2  SCKC   EXP1 ; shift B by difference in exponents (C) to line up
0 0100 1111 004F	01 00101 0010           BINE   DONE2
0 0101 0000 0050	11 11000 0100           SRLB   MANT
0 0101 0001 0051	00 00100 1110           BIE    BSHIFT2 ; branch every time
0 0101 0010 0052	11 11110 0001  DONE2    ABAC   MANT_S5 ; add mantissa signs and subtract 5
0 0101 0011 0053	11 01011 0001           SCKC   MANT_S5
0 0101 0100 0054	00 00101 1001           BIE    SUBMANT ; signs different
0 0101 0101 0055	11 00000 0100  TRYADD   AABA   MANT ; add mantissas, or restore A if did SUBMANT
0 0101 0110 0056	00 01000 0010           BIE    NORMLIZE ; branch if no overflow, i.e. did add
0 0101 0111 0057	11 10011 0100           EXAB   MANT ; failed subtract: swap A and B and try again.
0 0101 1000 0058	11 10011 0001           EXAB   MANT_S5
; Try subtracting mantissas: A-B. If B>A, add B back, swap, and try again
0 0101 1001 0059	11 00111 0100  SUBMANT  SABA   MANT ; subtract mantissa
0 0101 1010 005A	01 00101 0101           BINE   TRYADD ; A was smaller than B: try again
0 0101 1011 005B	00 01000 0010           BIE    NORMLIZE ; branch every time, done
; Multiplication: add exponents with different signs
0 0101 1100 005C	11 01100 0010  SIGNSNE  CAB    EXP ; compare EXP magnitudes
0 0101 1101 005D	00 00101 1111           BIE    SUBEXPS ; branch if |A| >= |B|
0 0101 1110 005E	11 10011 1001           EXAB   EXPSGNS1 ; swap exponents and signs
; At this point, |A| >= |B|, so can subtract and A's sign won't change
0 0101 1111 005F	11 00111 0010  SUBEXPS  SABA   EXP ; subtract EXPs
0 0110 0000 0060	00 00111 0010           BIE    EXPSDONE ; branch every time
; Division entry point: compute C / A.
; First, normalize A mantissa since repeatedly subtracting A depends on
; having A normalized. Next, use multiply's add-exponent code to subtract
; A's exponent from C's.
; The DIVLOOP loop repeatedly subtracts B from C, counting into A.
; Successive loops shift by 10 to perform long division.
0 0110 0001 0061	10 11010 0011  DIVKEY   TFA    UP_LOW ; entry point for DIV
0 0110 0010 0062	01 01010 0011           BINE   TANKEY ; alt-DIV is TAN
0 0110 0011 0063	10 10100 1011           SFA    COS_TAN ; reusing flag to indicate division
0 0110 0100 0064	10 10100 0001 DODIV    SFA    RET1FLAG ; 'subroutine call' flag
0 0110 0101 0065	00 01000 0010          BIE    NORMLIZE ; 'Subroutine call' to normalize A
0 0110 0110 0066	10 11000 0001 RET1     ZFA    RET1FLAG ; 'Return' here after NORMLIZE
0 0110 0111 0067	11 00001 0111          AAKA   EXP_S5 ; toggle A's EXP sign since dividing not multiplying
0 0110 1000 0068	00 00110 1001          BIE    MULTKEY ; clear cc
; Multiply by adding exponents and multiplying mantissas
; If COS_TAN set, divide by adding exponents, then jump to DIVMANT
; i.e. the code to add exponents is reused for division
0 0110 1001 0069	10 11010 0011*MULTKEY  TFA    UP_LOW ; alt-MULT is LOG
0 0110 1010 006A	01 01110 1110          BINE   LOGKEY
0 0110 1011 006B	11 10010 1111          AKC    DIGIT ; clear entered digit count
0 0110 1100 006C	11 00110 0000          ACKB   ALL ; copy C to B
0 0110 1101 006D	11 10011 0100          EXAB   MANT
; Add exponents; tricky if signs are different
0 0110 1110 006E	11 11110 0111          ABAC   EXP_S5
0 0110 1111 006F	11 01011 0111          SCKC   EXP_S5
0 0111 0000 0070	00 00101 1100          BIE    SIGNSNE ; if signs different, use SIGNSNE
0 0111 0001 0071	11 00000 0010          AABA   EXP ; simply add exponents
0 0111 0010 0072	11 00000 0001 EXPSDONE AABA   MANT_S5 ; xor signs
0 0111 0011 0073	00 00111 0100          BIE    CLRCC2 ; clear before test
0 0111 0100 0074	10 11010 1011 CLRCC2   TFA    COS_TAN ; set if dividing
; Compute A = B * C mantissas; EXP already computed
0 0111 0101 0075	11 10000 0100 MULTMANT AKA    MANT ; clear mantissa
0 0111 0110 0076	01 10001 0111          BINE   DIVMANT ; branch if dividing
0 0111 0111 0077	11 10111 0100 MLTLOOP1 SRLA   MANT ; multiply B * C
0 0111 1000 0078	11 01111 0101 MLTLOOP2 CCK    MANTLOW1 ; Add B to A, repeat low digit of C times
0 0111 1001 0079	01 00111 1101          BINE   MULTSHFT
0 0111 1010 007A	11 01011 1010          SCKC   MANT1
0 0111 1011 007B	11 00000 0100          AABA   MANT
0 0111 1100 007C	00 00111 1000          BIE    MLTLOOP2
0 0111 1101 007D	11 11001 0100 MULTSHFT SRLC   MANT ; shift C right
0 0111 1110 007E	11 01111 1010          CCK    MANT1
0 0111 1111 007F	00 00111 0111          BIE    MLTLOOP1 ; loop if not done
0 1000 0000 0080	10 11010 0101          TFA    LOW
0 1000 0001 0081	01 10011 0100          BINE   ALOGRET ; Return to ALOGRET if LOW flag set (ANTILOG)
; Normalizes mantissa by removing leading zeros.
; This is called to finish up after an operation
; Also subroutine call; RET1FLAG will cause return to RET1
0 1000 0010 0082	11 01101 1010 NORMLIZE CAK    MANT1 ; Test if mantissa is < 1
0 1000 0011 0083	01 00000 0000          BINE   START ; if mantissa is 0, reset
; Repeatedly shift MANT left until a value in the 5 digit.
; Decrement EXP each step to compensate
0 1000 0100 0084	11 01101 0011 MANTSHL  CAK    DIGIT1 ; Loop to left-align mantissa
0 1000 0101 0085	00 01001 0001          BIE    MANTOK ; Branch if mantissa aligned
0 1000 0110 0086	11 10100 0100          SLLA   MANT ; Shift mantissa left
; Decrementing the exponent is a bit tricky because sign is separate
; Cases are: positive exponent, exponent becoming -1, and negative exponent
0 1000 0111 0087	11 01101 0111          CAK    EXP_S5 ; Check exponent sign
0 1000 1000 0088	00 01000 1110          BIE    EXPNEG ; Branch if negative
0 1000 1001 0089	11 01001 0110          SAKA   EXP1 ; Decrement exponent
0 1000 1010 008A	00 01000 1101          BIE    EXPPOS3 ; Branch if no borrow
0 1000 1011 008B	11 10000 0111          AKA    EXP_S5 ; EXP went negative: Set exponent sign
0 1000 1100 008C	11 10000 0110          AKA    EXP1 ; Set exponent to 1
0 1000 1101 008D	11 01001 0110 EXPPOS3  SAKA   EXP1 ; Decrement exponent to cancel next instruction 
0 1000 1110 008E	11 00001 0110 EXPNEG   AAKA   EXP1 ; For negative exponent, inc EXP to decrement
0 1000 1111 008F	00 01000 0100          BIE    MANTSHL ; two branches to clear condition flag
0 1001 0000 0090	00 01000 0100          BIE    MANTSHL
; At this point, mantissa is left-aligned into digit 5
; Now shift one position right and increment exponent, taking sign into account
0 1001 0001 0091	11 10111 0100 MANTOK   SRLA   MANT
0 1001 0010 0092	11 01101 0111          CAK    EXP_S5 ; Test exponent sign
0 1001 0011 0093	01 01001 0110          BINE   EXPPOS
0 1001 0100 0094	11 01001 0110          SAKA   EXP1 ; Decrement exponent
0 1001 0101 0095	11 01001 0110          SAKA   EXP1 ; Decrement exponent
0 1001 0110 0096	11 00001 0110 EXPPOS   AAKA   EXP1 ; Increment exponent
0 1001 0111 0097	00 01001 1000          BIE    CLRCC1 ; clear condition
0 1001 1000 0098	10 11010 0001 CLRCC1   TFA    RET1FLAG ; Subroutine return
0 1001 1001 0099	01 00110 0110          BINE   RET1 ; return to RET1 if RET1FLAG set
; returned if RET1FLAG set, otherwise clean up...
; clear B, set OPDONE, clear A flags, fix EXP sign, copy A result to C
0 1001 1010 009A	10 10111 0000          ZFB    ALL ; Clear B
0 1001 1011 009B	10 10011 0110          SFB    OPDONE ; Set op done flag?
0 1001 1100 009C	10 11000 0000          ZFA    ALL ; Clear A flags
; Fix EXP of -00 if necessary
0 1001 1101 009D	11 01101 0110          CAK    EXP1 ; Is exponent zero (< 1)
0 1001 1110 009E	00 01010 0001          BIE    EXPPOS2
0 1001 1111 009F	11 00001 0111 CLEARSGN AAKA   EXP_S5 ; Flip sign
0 1010 0000 00A0	00 01001 1111          BIE    CLEARSGN ; Branch if sign was clear before
0 1010 0001 00A1	11 00010 0000 EXPPOS2  AAKC   ALL ; Copy A to C
0 1010 0010 00A2	00 00000 0100          BIE    MAINLOOP ; BET
; Entry points for TAN, COS, and SIN
0 1010 0011 00A3	10 10100 0111 TANKEY   SFA    TAN
0 1010 0100 00A4	10 10100 1011 COSKEY   SFA    COS_TAN
0 1010 0101 00A5	11 01001 0110 SINKEY   SAKA   EXP1 ; shift mantissa by exponent
0 1010 0110 00A6	01 01010 1001          BINE   DONESHFT
0 1010 0111 00A7	11 10111 0100          SRLA   MANT
0 1010 1000 00A8	00 01010 0101          BIE    SINKEY
0 1010 1001 00A9	11 10000 1001 DONESHFT AKA    EXPSGNS1 ; clear signs
0 1010 1010 00AA	11 01001 1001          SAKA   EXPSGNS1 ; EXP = 0
0 1010 1011 00AB	11 10010 0000          AKC    ALL ; clear C
0 1010 1100 00AC	10 11010 0101          TFA    LOW ; check for ARC-
0 1010 1101 00AD	00 01011 0100          BIE    NORMOP ; branch if no
0 1010 1110 00AE	10 11010 0111          TFA    TAN ; check ARCTAN?
0 1010 1111 00AF	00 01011 0011          BIE    ASINCOS ; branch if no
0 1011 0000 00B0	11 00010 0000          AAKC   ALL ; ARCTAN: copy A to C
0 1011 0001 00B1	11 10001 1011          AKB    MASKA1 ; set digit in B
0 1011 0010 00B2	00 01011 1001          BIE    TRGLOOP2 ; branch every time
0 1011 0011 00B3	11 00001 1101 ASINCOS  AAKA   MANTD1
0 1011 0100 00B4	11 10001 1100 NORMOP   AKB    MANTD5 ; B = .0005 (current SIN)
0 1011 0101 00B5	11 11000 0100          SRLB   MANT
0 1011 0110 00B6	11 11101 1011          ACKC   MASKA1 ; C += 1 (current COS)
; Loop test for SIN/COS/TAN
0 1011 0111 00B7	11 01001 1101 TRIGLOOP SAKA   MANTD1 ; rotate A times, by .001 rad
0 1011 1000 00B8	01 01110 0010          BINE   TRIGDONE ; branch on borrow - done
; The main trig loop. B holds sin, C holds cos.
; The loop is performed A times, rotating by .001 rad each time.
0 1011 1001 00B9	11 10110 0000 TRGLOOP2 SLLC   ALL ; shift C to prepare for add
0 1011 1010 00BA	11 10110 0000          SLLC   ALL
0 1011 1011 00BB	11 10110 0000          SLLC   ALL
0 1011 1100 00BC	11 11101 1100          ACKC   MANTD5 ; C=C-B/1000 (rounded)
0 1011 1101 00BD	11 01010 0000          SCBC   ALL
0 1011 1110 00BE	11 11001 0000          SRLC   ALL ; restore C
0 1011 1111 00BF	11 11001 0000          SRLC   ALL
0 1100 0000 00C0	11 11001 0000          SRLC   ALL
0 1100 0001 00C1	11 10101 0000          SLLB   ALL ; shift B to prepare for add
0 1100 0010 00C2	11 10101 0000          SLLB   ALL
0 1100 0011 00C3	11 10101 0000          SLLB   ALL
0 1100 0100 00C4	11 11101 1100          ACKC   MANTD5 ; B=B+C/1000 (rounded)
0 1100 0101 00C5	11 00011 0000          ABCB   ALL
0 1100 0110 00C6	11 01011 1100          SCKC   MANTD5 ; restore C
0 1100 0111 00C7	11 11000 0000          SRLB   ALL
0 1100 1000 00C8	11 11000 0000          SRLB   ALL
0 1100 1001 00C9	11 11000 0000          SRLB   ALL
0 1100 1010 00CA	10 11010 0101          TFA    LOW ; ARC-op?
0 1100 1011 00CB	00 01011 0111          BIE    TRIGLOOP ; no: branch
; Increment ARC-trig count, check termination
0 1100 1100 00CC	11 00001 1001          AAKA   EXPSGNS1 ; Count iterations in top digits of A
0 1100 1101 00CD	10 11010 0111          TFA    TAN
0 1100 1110 00CE	00 01101 0010          BIE    ASINCOS1 ; branch if SIN/COS
; Test ARCTAN termination
0 1100 1111 00CF	11 01111 0011          CCK    DIGIT1 ; ARCTAN, compare C to K
0 1101 0000 00D0	01 01011 1001          BINE   TRGLOOP2 ; loop if not done
0 1101 0001 00D1	00 01101 1100          BIE    ARCDONE ; BET
0 1101 0010 00D2	10 11010 1011 ASINCOS1 TFA    COS_TAN ; SIN/COS
0 1101 0011 00D3	01 01101 0111          BINE   ACOSCHK ; branch if COS
; Test ARCSIN termination
0 1101 0100 00D4	11 01100 0100          CAB    MANT ; must be SIN
0 1101 0101 00D5	00 01011 1001          BIE    TRGLOOP2
0 1101 0110 00D6	00 01101 1100          BIE    ARCDONE ; Branch every time
; Test ARCCOS termination
0 1101 0111 00D7	11 01101 1010 ACOSCHK  CAK    MANT1 ; COS
0 1101 1000 00D8	11 10011 0100          EXAB   MANT ; compare C-A the hard way
0 1101 1001 00D9	11 01110 0100          CCB    MANT
0 1101 1010 00DA	11 10011 0100          EXAB   MANT
0 1101 1011 00DB	00 01011 1001          BIE    TRGLOOP2 ; C==A
0 1101 1100 00DC	11 10111 0000 ARCDONE  SRLA   ALL ; shift iteration count into mantissa, divide by 1000
0 1101 1101 00DD	11 10111 0000          SRLA   ALL
0 1101 1110 00DE	11 10111 0000          SRLA   ALL
0 1101 1111 00DF	11 10111 0000          SRLA   ALL
0 1110 0000 00E0	11 10111 0000          SRLA   ALL
0 1110 0001 00E1	00 01000 0010          BIE    NORMLIZE ; branch every time
; SIN/COS/TAN loop done
0 1110 0010 00E2	10 11010 0111 TRIGDONE TFA    TAN
0 1110 0011 00E3	00 01110 1001          BIE    SINCOS
0 1110 0100 00E4	11 00101 0000          ACKA   ALL ; doing TAN: A=C (denom)
0 1110 0101 00E5	11 00100 0000          ABOC   ALL ; C=B (numer)
0 1110 0110 00E6	11 10001 0000          AKB    ALL ; B=0
0 1110 0111 00E7	10 11000 0011          ZFA    UP_LOW
0 1110 1000 00E8	00 00110 0100          BIE    DODIV ; branch every time
0 1110 1001 00E9	10 11010 1011 SINCOS   TFA    COS_TAN
0 1110 1010 00EA	00 01110 1100          BIE    SIN ; branch for SIN
0 1110 1011 00EB	11 00110 0000          ACKB   ALL ; COS: return C via B
0 1110 1100 00EC	11 10011 0000 SIN      EXAB   ALL ; SIN: return B
0 1110 1101 00ED	00 01000 0010          BIE    NORMLIZE ; BET (no overflow)
0 1110 1110 00EE	10 11010 0101 LOGKEY   TFA    LOW ; low-MULT is antilog
0 1110 1111 00EF	00 01111 1011          BIE    LOG
; Antilog entry point.
; The concept is to split the integer and fractional part of A. The integer
; part becomes the EXP of the result. The antilog of the fractional part is 
; computed using the equation 10^f = 10*.99^(229.15*(1-f))
; 
; First, split int and frac parts of A. Next LOGLOOP computes constant 229.15.
; Control continues at ANTILOG which calls MULTMANT to multiply 1-frac by 229.15
0 1111 0000 00F0	11 01101 0110 DOALOG   CAK    EXP1 ; Test exponent
; Split int and frac parts of A: int in digits 1-4, frac in 7-10
; Shortcut: If EXP > 0, assume EXP is 1. Anything bigger would probably overflow
; This is totally wrong for cases like antilog(0.001E3)
0 1111 0001 00F1	01 01111 1000          BINE   EXPZERO ; branch if exponent is 0
0 1111 0010 00F2	11 01101 0111          CAK    EXP_S5; Test exponent sign
0 1111 0011 00F3	01 01111 0111          BINE   EXPPOS4
0 1111 0100 00F4	11 10111 0100          SRLA   MANT; Negative exponent: shift mantissa right to align
0 1111 0101 00F5	11 01001 0110          SAKA   EXP1
0 1111 0110 00F6	00 01111 0000          BIE    DOALOG ; Loop every time
0 1111 0111 00F7	11 10100 0100 EXPPOS4  SLLA   MANT ; Positive EXP, assume it is 1
0 1111 1000 00F8	11 10000 0010 EXPZERO  AKA    EXP ; Clear exponent
0 1111 1001 00F9	11 10100 1000          SLLA   TOPSTUFF ; Shift integer part into digits 1-4 for later
0 1111 1010 00FA	11 10100 1000          SLLA   TOPSTUFF
; Compute log of A.
; First compute -1/log(.99) = 229.15. Then compute -log(MANT A)/log(.99).
; Divide the results to get log(MANT A). Finally, add EXP A to get the result.
; Then compute -log(A)/go through power loop a second time
0 1111 1011 00FB	11 10010 0000 LOG      AKC    ALL ; This entry point computes -1/log(.99) = 229.15
0 1111 1100 00FC	11 11101 0011          ACKC   DIGIT1 ; C = 10.00000
; LOGLOOP is used twice; once to compute the constant 229.15 and then again
; on the actual argument.
; Compute -log(C MANT) / log(.99).
; Do this by repeatedly incrementing count until (C MANT)*.99^count is < 1
; That yields count = -log(C) / log(.99) approximately
; count is stored in C EXP, and the current C*.99 in C MANT
0 1111 1101 00FD	11 00110 0100 LOGLOOP  ACKB   MANT ; Compute log B*.99^C until < .1
0 1111 1110 00FE	11 11000 0100          SRLB   MANT
0 1111 1111 00FF	11 11000 0100          SRLB   MANT
1 0000 0000 0100	11 01010 0100          SCBC   MANT ; C -= C / 100
1 0000 0001 0101	10 11001 0111          TFB    NEWEXP ; indicates ALOG here
1 0000 0010 0102	01 10011 0111          BINE   ALOGLOOP
1 0000 0011 0103	11 11101 1001          ACKC   EXPSGNS1 ; Count number of iterations
1 0000 0100 0104	11 01111 1011          CCK    MASKA1 ; C vs 100000
1 0000 0101 0105	00 01111 1101          BIE    LOGLOOP ; Loop if >=
; Get a couple decimal points of accuracy by adding the remainder*100
; Explanation using Taylor series:
; .99^(epsilon*100) = 1-epsilon = 1/(1+epsilon) approximately
; So if C*.99^N = 1+epsilon, then C*.99^(N+epsilon*100) = (1+epsilon)/(1+epsilon) = 1
; Thus N + epsilon * 100 is the better approximation
1 0000 0110 0106	11 11100 1001          SCBB   EXPSGNS1 ; undo last iteration: count in B EXP
1 0000 0111 0107	11 11111 0100          ABCC   MANT ; undo last MANT subtract
1 0000 1000 0108	11 01011 1011          SCKC   MASKA1
1 0000 1001 0109	11 11000 0000          SRLB   ALL ; Shift count into B mantissa
1 0000 1010 010A	11 11000 0000          SRLB   ALL
1 0000 1011 010B	11 11000 0000          SRLB   ALL
1 0000 1100 010C	11 11000 0000          SRLB   ALL
1 0000 1101 010D	11 00011 0100          ABCB   MANT ; add epsilon*100
1 0000 1110 010E	11 10011 0100          EXAB   MANT ; result in A MANT
1 0000 1111 010F	10 11010 0101*         TFA    LOW
1 0001 0000 0110	01 10010 1110          BINE   ANTILOG ; return to ANTILOG if LOW set
1 0001 0001 0111	11 00100 0000          ABOC   ALL ; Copy B (arg) to C
1 0001 0010 0112	10 11100 0111          FFA    TAN ; go through loop twice, tracked by TAN flag
1 0001 0011 0113	10 11010 0111          TFA    TAN
1 0001 0100 0114	01 01111 1101          BINE   LOGLOOP ; back to the loop with the argument
; Second power loop done for LOG. A EXP is original EXP.
; A MANT = -log(original A MANT) / log(.99)
; B MANT = 229.15 = -1 / log(.99)
; Copy A MANT to C MANT, then compute C MANT / B MANT
; This yields A MANT = log(original A MANT)
1 0001 0101 0115	11 00010 0100*         AAKC   MANT
; For LOG fall-through: 229.15 in B, -log(arg)/log(.99) in A and C
; At ALOGDIV entry: 1+epsilon in B, .99^N in C
1 0001 0110 0116	11 10000 0100 ALOGDIV  AKA    MANT ; clear A mant, arg exp still in A
; Compute A MANT = C MANT / B MANT by long division
1 0001 0111 0117	11 10000 1110 DIVMANT  AKA    DIGIT4 ; start digit count at 4, iterate until 10
; The DIVLOOP loop repeatedly subtracts B from C, counting into A
1 0001 1000 0118	11 01110 0100 DIVLOOP  CCB    MANT ; Compare C and B to see if subtraction done
1 0001 1001 0119	01 10001 1101          BINE   SHIFTDIV ; branch if C < B
1 0001 1010 011A	11 01010 0100          SCBC   MANT ; C -= B
1 0001 1011 011B	11 00001 1010          AAKA   MANT1 ; increment low digit of A
1 0001 1100 011C	00 10001 1000          BIE    DIVLOOP ; BET
1 0001 1101 011D	11 00010 0011 SHIFTDIV AAKC   DIGIT1 ; increment digit count into C
1 0001 1110 011E	01 10010 0011          BINE   DIVDONE ; overflow; done when count hits 10
1 0001 1111 011F	11 10100 0100          SLLA   MANT ; shift A mantissa left
1 0010 0000 0120	11 00101 1111          ACKA   DIGIT ; copy digit count back to A; clears flag
1 0010 0001 0121	11 10110 0100          SLLC   MANT ; and shift C mantissa left
1 0010 0010 0122	00 10001 1000          BIE    DIVLOOP ; branch every time
1 0010 0011 0123	11 10000 1111 DIVDONE  AKA    DIGIT; NOP to clear flag
1 0010 0100 0124	10 11010 0011          TFA    UP_LOW ; pick the return target
1 0010 0101 0125	01 10010 1000          BINE   ADDLOG ; continue for LOG
1 0010 0110 0126	00 01000 0010          BIE    NORMLIZE ; done for DIV
1 0010 0111 0127	00 00000 1010 WAITED   BIE    WAITED2 ; inconvenient WAITNO target
; For LOG, add (original) A exponent to result via ADDSUB
1 0010 1000 0128	11 00010 0100 ADDLOG   AAKC   MANT ; A mantissa -> C
1 0010 1001 0129	11 10000 0100          AKA    MANT ; clear A mantissa
1 0010 1010 012A	11 10111 0000          SRLA   ALL ; shift exponent into top of mantissa (log of exponent)
1 0010 1011 012B	11 10111 0000          SRLA   ALL
1 0010 1100 012C	11 10000 0010          AKA    EXP ; clear exponent
; At this point, original EXP is in A digits 5 and 6, log of original MANT is in C
; Add them together to get final log
1 0010 1101 012D	00 00011 1101          BIE    ADDSUB ; BET (clear from AAKC)
; A holds the original int part in digits 1-4, 229.15 in digits 6-10
; B holds the original fractional part in digits 6-10
1 0010 1110 012E	11 00010 0100 ANTILOG  AAKC   MANT ; copy 229.15 to C
1 0010 1111 012F	11 10000 0100          AKA    MANT ; clear A MANT
1 0011 0000 0130	11 10000 1011          AKA    MASKA1
1 0011 0001 0131	11 00111 0100          SABA   MANT
1 0011 0010 0132	11 10011 0100          EXAB   MANT; B holds 1 - original fractional part
1 0011 0011 0133	00 00111 0101          BIE    MULTMANT ; Sub call to multiply by 229.15
1 0011 0100 0134	11 10111 0100*ALOGRET  SRLA   MANT
1 0011 0101 0135	10 10011 0111          SFB    NEWEXP; indicates ALOG
1 0011 0110 0136	00 01111 1011          BIE    LOG ; Branch every time
; conditional for LOGLOOP when doing ANTILOG
; loop number of times in A MANT
1 0011 0111 0137	11 01001 1101 ALOGLOOP SAKA   MANTD1 ; decrement A and if non-negative...
1 0011 1000 0138	00 01111 1101          BIE    LOGLOOP ; go back to LOGLOOP
; Get a couple more digits of accuracy. The idea is that
; .99^epsilon = 1-epsilon/100 = 1/(1+epsilon/100)) approximately
; so divide by 1+remainder/100 to account for the fractional part of
; the exponent in .99^N, since the loop only does the integer part.
1 0011 1001 0139	11 00001 1101*         AAKA   MANTD1 ; restore A digits to 0
1 0011 1010 013A	11 10100 0100          SLLA   MANT ; use the ignored digits for extra accuracy?
1 0011 1011 013B	11 00001 1011          AAKA   MASKA1; A = 1 + remainder/100
1 0011 1100 013C	11 11111 0100          ABCC   MANT; restore value of C from extra iteration
1 0011 1101 013D	11 10011 0100          EXAB   MANT; B has correction factor, C has 10*.99^N
1 0011 1110 013E	10 11000 0011          ZFA    UP_LOW
1 0011 1111 013F	00 10001 0110          BIE    ALOGDIV ; BET divide and finish up ALOG

; -- ORIGINAL
;1 0011 1111 013F	01 10001 0110          BINE   ALOGDIV ; BET divide and finish up ALOG
; -- /ORIGINAL

;  
; A Flags:
; 0 ALL - all flags, for clearing
; 1 (S10) RET1FLAG - indicates return to DIV
; 3 (S6) UP_LOW - indicates either UP or LOW functions
; 5 (S0) LOW - indicates a LOW function
; 7 (S9) TAN - indicates TAN selected
; 11 (S5) COS_TAN - indicates COS or TAN selected
; 
; B Flags:
; 0 ALL - all flags, for clearing
; 1 (S10) EMODE - indicates E has been pressed
; 6 (S8S7) OPDONE - indicates operation completed, waiting for number
; 7 (S9) NEWEXP: E pressed, entering a new exponent; also for ALOG
;  
; Masks:
;  S value
; a9876543210
; 00000000000 mask 0 ALL - all digits
; 5           mask 1 MANT_S5 - mantissa sign; 5 is negative
;   00        mask 2 EXP - exponent for value
;     1       mask 3 DIGIT1
;     0000000 mask 4 MANT - mantissa
;           1 mask 5 MANTLOW1 - low digit of mantissa
;   01        mask 6 EXP1 - mantissa constant 1
;  5          mask 7 EXP_S5 - exponent sign; 5 is negative
; 000000      mask 8 TOPSTUFF
; 0001        mask 9 EXPSGNS1 - exponent and signs, also a counter
;     0000001 mask a MANT1 - mantissa constant 1
;      1      mask b MASKA1 - counter or digit in mantissa
;     00005   mask c MANTD5
;     00001   mask d MANTD1
;     4       mask e DIGIT4
;     0       mask f DIGIT
//var objectCode = [
//1408,1392,1792,1824,1860,1808,1360,1376,
//518,1319,1360,1376,9,1360,1908,1072,
//1083,1075,1121,1129,1073,1069,1051,1840,
//1955,1840,516,1425,552,1430,33,1792,
//1398,1631,1920,1683,34,2003,1540,4,
//1399,1858,1872,1538,4,1329,1335,4,
//1349,1347,4,1443,676,1431,57,1559,
//4,1553,59,1443,677,1839,1632,2018,
//65,2023,1719,72,1730,71,1840,1666,
//1751,587,1840,1754,78,1840,1718,594,
//1924,78,2017,1713,89,1540,130,1844,
//1841,1652,597,130,1730,95,1849,1650,
//114,1443,675,1355,1345,130,1409,1559,
//105,1443,750,1839,1632,1844,2023,1719,
//92,1538,1537,116,1451,1796,791,1908,
//1781,637,1722,1540,120,1940,1786,119,
//1445,820,1754,512,1747,145,1860,1751,
//142,1686,141,1799,1798,1686,1558,132,
//132,1908,1751,662,1686,1686,1558,152,
//1441,614,1392,1334,1408,1750,161,1559,
//159,1568,4,1351,1355,1686,681,1908,
//165,1801,1689,1824,1445,180,1447,179,
//1568,1819,185,1565,1820,1924,2011,1693,
//738,1888,1888,1888,2012,1696,1936,1936,
//1936,1872,1872,1872,2012,1584,1724,1920,
//1920,1920,1445,183,1561,1447,210,1779,
//697,220,1451,727,1732,185,220,1754,
//1844,1764,1844,185,1904,1904,1904,1904,
//1904,130,1447,233,1616,1600,1808,1411,
//100,1451,236,1632,1840,130,1445,251,
//1750,760,1751,759,1908,1686,240,1860,
//1794,1864,1864,1824,2003,1636,1924,1924,
//1700,1431,823,2009,1787,253,1993,2036,
//1723,1920,1920,1920,1920,1588,1844,1445,
//814,1600,1479,1447,765,1572,1796,1806,
//1764,797,1700,1562,280,1571,803,1860,
//1631,1892,280,1807,1443,808,130,10,
//1572,1796,1904,1904,1794,61,1572,1796,
//1803,1652,1844,117,1908,1335,251,1693,
//253,1565,1860,1563,2036,1844,1411,790,
//];
