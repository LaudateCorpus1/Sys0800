using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

namespace AsmGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            string rawLine, cookedLine;
            int lineCounter, parseCounter;
            bool objectCodeLine, sourceCodeLine;
            int address, instruction;
            StringBuilder objectCodeBuilder = new StringBuilder();
            string objectCodeString;
            string[] objectCode;

            // Banner and basic param check
            System.Console.WriteLine("-------------------------------------------------------------------------------------------------");
            System.Console.WriteLine("AsmGenerator: ");
            System.Console.WriteLine("Convert TMS0800 source code from http://righto.com/ti to https://github.com/zpekic/Sys0800 format");
            System.Console.WriteLine("-------------------------------------------------------------------------------------------------");
            System.Console.WriteLine();

            CheckRange(args.Length, 2, 2, "Both source and destination files must be specified.");

            // 1st pass: read the file and extract object code 
            System.IO.StreamReader sourceFile = getStreamReader(args[0]);
            lineCounter = 0;
            parseCounter = 0;
            objectCodeLine = false;
            while ((rawLine = sourceFile.ReadLine()) != null)
            {
                lineCounter++;
                cookedLine = rawLine.Trim();
                if (!string.IsNullOrEmpty(cookedLine))
                {
                    if (objectCodeLine)
                    {
                        if (cookedLine.IndexOf("];") >= 0)
                        {
                            objectCodeLine = false;
                        }
                        else
                        {
                            parseCounter++;
                            objectCodeBuilder.Append(cookedLine);
                        }
                    }
                    else
                    {
                        if (cookedLine.IndexOf("objectCode") > 0)
                        {
                            objectCodeLine = true;
                        }
                    }
                }
            }

            sourceFile.Close();

            objectCodeString = objectCodeBuilder.ToString();
            if (objectCodeString.EndsWith(","))
            {
                // ending comma would generate a empty object code value in the array
                objectCodeString = objectCodeString.TrimEnd(',');
            }
            objectCode = objectCodeString.Split(',');

            CheckRange(objectCode.Length, 317, 320, "Invalid number of object code words.");
            for (int i = 0; i < objectCode.Length; i++)
            {
                CheckRange(int.Parse(objectCode[i]), 0, (1 << 12) - 1, "Invalid object code word value.");
            }

            System.Console.WriteLine("Pass 1 over {0}: {1} object code lines found out of {2} total lines.", args[0], parseCounter.ToString(), lineCounter.ToString());

            // 2nd pass: generate target file by replacing lines numbers with object code in proper format
            sourceFile = getStreamReader(args[0]);
            System.IO.StreamWriter destFile = new System.IO.StreamWriter(args[1], false);
            destFile.WriteLine("//-----------------------------------------------------------------------------------");
            destFile.WriteLine(string.Format("// Generated by AsmGenerator.exe from '{0}' on {1} {2} for use in https://github.com/zpekic/Sys0800", args[0], DateTime.Now.ToShortDateString(), DateTime.Now.ToShortTimeString(), args[0]));
            destFile.WriteLine("//-----------------------------------------------------------------------------------");
            destFile.WriteLine("//Add * after the last binary digit of instruction to generate breakpoint for TMS0800");
            destFile.WriteLine("//-----------------------------------------------------------------------------------");
            destFile.WriteLine();

            lineCounter = 0;
            parseCounter = 0;
            sourceCodeLine = false;
            while ((rawLine = sourceFile.ReadLine()) != null)
            {
                lineCounter++;
                cookedLine = rawLine.Trim();
                if (!string.IsNullOrEmpty(rawLine))
                {
                    if (sourceCodeLine)
                    {
                        if (cookedLine.IndexOf("];") >= 0)
                        {
                            sourceCodeLine = false;
                        }
                        else
                        {
                            cookedLine = cookedLine.TrimEnd(new char[] { ',' });
                            cookedLine = cookedLine.Trim(new char[] { '"' });
                            cookedLine = cookedLine.Trim(new char[] { '\'' });

                            int firstSpace = cookedLine.IndexOf(" ");

                            if ((firstSpace > 0 ) && (int.TryParse(cookedLine.Substring(0, firstSpace), out address)))
                            {
                                parseCounter++;
                                instruction = int.Parse(objectCode[address]);
                                objectCode[address] = null; // to prevent reuse
                                cookedLine = getFormattedData(address, instruction) + cookedLine.Substring(firstSpace);
                            }

                            destFile.WriteLine(cookedLine);
                        }
                    }
                    else
                    {
                        if (cookedLine.IndexOf("sourceCode") > 0)
                        {
                            sourceCodeLine = true;
                        }
                        else
                        {
                            if (!cookedLine.StartsWith("//"))
                            {
                                destFile.Write("//");
                            }
                            destFile.WriteLine(cookedLine);
                        }
                    }
                }
                else
                {
                    destFile.WriteLine();
                }
            }

            sourceFile.Close();
            destFile.Flush();
            destFile.Close();

            // check that all of objectCode has been consumed
            for (int i = 0; i < objectCode.Length; i++)
            {
                if (objectCode[i] != null)
                {
                    throw new Exception("Destination file may be invalid - not all object code is used.");
                }
            }

            System.Console.WriteLine("Pass 2 over {0}: {1} source code lines found out of {2} total lines.", args[0], parseCounter.ToString(), lineCounter.ToString(), args[1]);

            System.Console.WriteLine("File {0} generated.", args[1]);
        }

        internal static string getFormattedData(int address, int instruction)
        {
            CheckRange(address, 0, 319, "Address is out of range!");
            CheckRange(instruction, 0, (1 << 12) - 1, "Instruction is out of range!");

            string abin = getBinaryString(address, 9);
            string ahex = string.Format("{0:X4}", address);
            string ibin = getBinaryString(instruction, 11);

            return abin.Substring(0, 1) + " " + abin.Substring(1, 4) + " " + abin.Substring(5, 4) + " " + ahex + "\t" + ibin.Substring(0, 2) + " " + ibin.Substring(2, 5) + " " + ibin.Substring(7, 4);
        }

        internal static void CheckRange(int value, int min, int max, string error)
        {
            if ((value < min) || (value > max))
            {
                throw new ArgumentOutOfRangeException("value", value, error);
            }
        }

        internal static string getBinaryString(int number, int length)
        {
            int mask = 1;
            string binary = string.Empty;
            for (int i = 0; i < length; i++)
            {
                binary = ((number & mask) != 0 ? "1" : "0") + binary;
                mask = mask << 1;
            }

            return binary;
        }

        internal static System.IO.StreamReader getStreamReader(string fileNameOrUri)
        {
            if (fileNameOrUri.StartsWith("http", true, System.Globalization.CultureInfo.InvariantCulture))
            {
                WebClient webClient = new WebClient();
                System.IO.Stream webStream = webClient.OpenRead(fileNameOrUri);
                return new System.IO.StreamReader(webStream);
            }
            else
            {
                return new System.IO.StreamReader(fileNameOrUri);
            }
        }
    }
}
